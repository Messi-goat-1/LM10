الخلاصة (دورة حياة الملف):server.go
1. دالة OnMessage(msg ChunkMessage)
هي "القلب النابض" للملف والنقطة التي تستقبل أي رسالة قادمة:

التحقق: تبدأ بالتأكد من أن الرسالة صالحة عبر ValidateMessage.

إذا كانت الرسالة جزءاً عادياً: تقوم بتخزين الجزء على القرص الصلب باستخدام StoreChunk.

إذا كانت الرسالة هي النهاية (IsEOF): 1. تقوم بتجميع كل الأجزاء في ملف واحد عبر AssembleFile. 2. ترسل الملف المكتمل للتحليل عبر ProcessFile. 3. تحذف الأجزاء المؤقتة لتوفير المساحة عبر Cleanup.

2. دالة ValidateMessage(msg ChunkMessage)
دالة أمنية بسيطة للتأكد من البيانات:

تتحقق من وجود FileID (معرف الملف).

تتأكد أن الرسالة ليست فارغة إلا إذا كانت مجرد إشارة لنهاية الملف (IsEOF).

3. دالة StoreChunk(msg ChunkMessage)
مسؤولة عن التخزين المؤقت:

تنشئ مجلداً خاصاً لكل ملف داخل مجلد temp_chunks باستخدام معرف الملف.

تحفظ كل قطعة في ملف مستقل يسمى part_X (حيث X هو رقم القطعة).

تستخدم نظام الملفات (القرص) بدلاً من الذاكرة العشوائية لتجنب استهلاك الرام في الملفات الضخمة.

4. دالة IsFileComplete(fileID string)
دالة فحص:

تتأكد ما إذا كان هناك أجزاء مخزنة بالفعل للملف المطلوب في المجلد المؤقت.

5. دالة AssembleFile(fileID string)
هي المسؤولة عن "إعادة البناء":

تنشئ ملفاً نهائياً بصيغة .pcap داخل مجلد uploads.

تبحث عن القطع بالترتيب (part_0, part_1, ...) وتدمج محتواها داخل الملف النهائي.

تتوقف فور عدم العثور على القطعة التالية في التسلسل.

المخرج: تعيد المسار الكامل للملف الذي تم تجميعه.

6. دالة ProcessFile(fileID string, filePath string)
جسر التواصل مع وحدة التحليل:

تأخذ مسار الملف المكتمل وترسله إلى حزمة (package) خارجية تسمى analysis لتنفيذ دالة AnalyzePCAP. هنا يتم فحص محتوى ملف الـ PCAP تقنياً.

7. دالة Cleanup(fileID string)
دالة التدبير المنزلي:

بعد انتهاء التجميع والتحليل، تقوم بحذف المجلد المؤقت الذي يحتوي على القطع الصغيرة (temp_chunks/fileID) لتنظيف السيرفر.
وصول قطع: StoreChunk تحفظها واحدة تلو الأخرى.

وصول إشارة النهاية: AssembleFile يجمعها في ملف .pcap واحد.

التحليل: ProcessFile يحلل الملف المكتمل.

التنظيف: Cleanup يمسح القطع التي لم نعد بحاجتها.



ملخص سير العمل
:rebbit.go
1. الهيكل RabbitClient
هذا الهيكل يمثل "العميل" الذي سيتعامل مع RabbitMQ.

conn: يمثل الاتصال الفعلي (TCP Connection) مع الخادم.

channel: القناة التي يتم عبرها إرسال واستقبال البيانات (القنوات أخف من الاتصالات الكاملة).

2. دالة NewRabbitClient
هذه هي دالة الإنشاء (Constructor):

تأخذ عنوان السيرفر (url) وتقوم بفتح اتصال.

تفتح قناة اتصال داخل هذا الرابط.

تعيد كائن RabbitClient جاهز للاستخدام.

3. دالة Close
دالة التنظيف:

تضمن إغلاق القناة والاتصال بشكل آمن عند انتهاء الحاجة للسيرفر، لمنع تسريب الموارد (Memory/Connection leaks).

4. دالة PublishMessage
مهمتها "إرسال" الرسائل:

تتأكد أولاً من وجود الطابور (QueueDeclare)؛ فإذا لم يكن موجوداً تقوم بإنشائه.

ترسل الرسالة النصية إلى الطابور المحدد باستخدام PublishWithContext.

5. دالة RunHeartbeat
دالة مراقبة (نبضات القلب):

تعمل بشكل آلي كل دقيقة واحدة (1 * time.Minute).

ترسل رسالة نصية لطابور يسمى server_status تخبر فيه النظام أن "السيرفر لا يزال يعمل" مع ذكر الوقت.

تفيد هذه الدالة في مراقبة حالة السيرفر عن بُعد.

6. دالة ConsumeMessages
مهمتها "استقبال" الرسائل:

تفتح باب الاستماع على طابور معين (queueName).

تستخدم "Goroutine" (دالة تعمل في الخلفية) لكي لا يتوقف البرنامج أثناء انتظار الرسائل.

عند وصول أي رسالة، تقوم بتمرير محتواها (d.Body) إلى دالة معالجة (processor) تقوم أنت بتعريفها لاحقاً.
الاتصال: ننشئ العميل بـ NewRabbitClient.

الإرسال: نستخدم PublishMessage لإرسال بيانات.

المراقبة: RunHeartbeat تعمل في الخلفية لتأكيد أن السيرفر متصل.

الاستقبال: ConsumeMessages تنتظر أي رسائل قادمة من أنظمة أخرى لتعالجها.
===
علاقة بين server.go and rabbit.go 
1. مرحلة الاستقبال (عبر rabbit.go)
تبدأ العملية عندما تصل رسائل (قطع ملف) إلى طابور RabbitMQ.

تقوم دالة ConsumeMessages في ملف rabbit.go بمراقبة هذا الطابور باستمرار.

بمجرد وصول بيانات، يتم تمريرها إلى دالة المعالجة (Processor).

2. مرحلة التحقق والتخزين (عبر server.go)
يتم تحويل البيانات المستلمة إلى هيكل ChunkMessage ثم إرسالها لدالة OnMessage.

تقوم دالة ValidateMessage بالتأكد من أن القطعة تحتوي على معرف ملف (FileID) وبيانات صحيحة.

إذا كانت قطعة عادية، تستدعي OnMessage دالة StoreChunk التي تقوم بإنشاء مجلد مؤقت على القرص وحفظ القطعة فيه بترتيبها (part_0, part_1...).

3. مرحلة التجميع والتحليل (عند اكتمال الملف)
عندما تصل رسالة تحتوي على علامة النهاية IsEOF == true:

تطلب OnMessage من دالة AssembleFile تجميع كل القطع المخزنة في ملف واحد بصيغة .pcap.

بعد التجميع، يتم تمرير مسار الملف النهائي إلى دالة ProcessFile التي ترسلها لمحرك التحليل analysis.AnalyzePCAP.

4. مرحلة التنظيف والمراقبة
التنظيف: بمجرد انتهاء التحليل، يقوم server.go باستدعاء Cleanup لحذف المجلد المؤقت الذي كان يحتوي على القطع لتوفير مساحة القرص.

المراقبة: في هذه الأثناء، تستمر دالة RunHeartbeat في rabbit.go بإرسال رسائل دورية كل دقيقة لتأكيد أن النظام ككل لا يزال يعمل ولم يتوقف أثناء معالجة الملفات الكبيرة.
