## Problem #1: Chunk Order Validation

â— **Type:**  
Data Integrity Bug
---
ğŸ“‚ **Location:**  
- **File:** `services/file_chunk.go`  
- **Functions:**  
  - `Manager.isComplete`  
  - `Manager.reassemble`
---
ğŸ” **Description:**  
    The completion logic relied only on the number of files in the chunk directory.  
    This allowed missing or unordered chunks to be treated as a complete file,  
    leading to silent data corruption during reassembly.
---
âŒ **Before (`isComplete`):**
go
files, _ := os.ReadDir(dir)
return len(files) == total

âœ… After (isComplete):

for i := 0; i < total; i++ {
    partPath := filepath.Join(dir, fmt.Sprintf("part_%d", i))
    if _, err := os.Stat(partPath); err != nil {
        return false
    }
}
return true
------------
âŒ Before (reassemble):

    Relied on directory listing order
    Did not enforce strict chunk sequence

âœ… After (reassemble):

for i := 0; i < totalChunks; i++ {
    partPath := filepath.Join(tempDir, fmt.Sprintf("part_%d", i))
    data, err := os.ReadFile(partPath)
    if err != nil {
        return fmt.Errorf("missing chunk %d: %w", i, err)
    }
    out.Write(data)
}

ğŸ§  Explanation:
    Ensures all required chunks (part_0 â†’ part_(n-1)) exist before reassembly
    Enforces strict, deterministic chunk order during file reconstruction
    Prevents silent corruption caused by missing or unordered chunks

ğŸ§ª Tests (to be added):
    TestManager_isComplete_MissingChunk
    TestManager_isComplete_AllChunksPresent
    TestManager_reassemble_MissingChunk
    TestManager_reassemble_OrderEnforced

----------------------------------
## Problem #2: Prevent Duplicate Chunk Writes (Idempotency)

â— Type:
    Data Consistency Bug

ğŸ“‚ Location:
    - File: services/file_chunk.go
    - Function: Manager.OnChunkReceived

ğŸ” Description:
    The same chunk may be received more than once due to retries or duplicate
    events. Writing the chunk blindly can overwrite existing data and lead to
    file corruption during reassembly.

âŒ Before:

os.WriteFile(chunkPath, data, 0644)

    This implementation overwrites existing chunks without validation.

âœ… After:
if existing, err := os.ReadFile(chunkPath); err == nil {
	if bytes.Equal(existing, data) {
		return nil // safe duplicate chunk
	}
	return fmt.Errorf(
		"chunk %d already exists with different content",
		chunkIndex,
	)
}

os.WriteFile(chunkPath, data, 0644)
s.WriteFile(chunkPath, data, 0644)
---
ğŸ§  Explanation:
    Ensures chunk writes are idempotent while preserving data integrity.
    Duplicate chunks with identical content are safely ignored, while conflicting
    duplicates are rejected to prevent silent data corruption.

ğŸ§ª Tests:
    TestOnChunkReceived_DuplicateChunkIgnored
    TestOnChunkReceived_DuplicateChunkConflict
âœ… Status:
    [x] Fixed
    [ ] Tested
-----------------------------------------------
## Problem #3: Ignoring JSON Unmarshal Errors

â— Type:
    Error Handling Bug

ğŸ“‚ Location:
    - File: handlers/dispatcher.go
    - Function: EventDispatcher.Dispatch

ğŸ” Description:
    Incoming event payloads are deserialized using `json.Unmarshal` without
    checking the returned error. If the JSON payload is malformed, incomplete,
    or does not match the expected event structure, the system will silently
    continue execution with a zero-value event.

    This can lead to invalid handlers being executed with corrupted data,
    causing unpredictable behavior that is difficult to debug.

âŒ Before:

var event events.FileChunkEvent
json.Unmarshal(data, &event)
d.chunkHandler.Handle(event)

The error returned by json.Unmarshal is ignored.

âœ… After:
var event events.FileChunkEvent
if err := json.Unmarshal(data, &event); err != nil {
	return err
}
d.chunkHandler.Handle(event)
ğŸ§  Explanation:
    JSON deserialization is a trust boundary. Ignoring unmarshal errors allows
    invalid or corrupted messages to propagate through the system silently.
    By explicitly handling the error, the dispatcher ensures that only valid
    events reach their handlers, improving system reliability and debuggability.

ğŸ§ª Tests:
    TestDispatch_InvalidJSON_ReturnsError
    TestDispatch_ValidEvent_DispatchedCorrectly

---------------------------------------
## Improvement #4: Event Dispatcher (OCP)
â— Type: Design Improvement (Open/Closed Principle)

ğŸ“‚ Location: 
    - File: handlers/dispatcher.go - Function: EventDispatcher.Dispatch

ğŸ” Description:
    The dispatcher currently uses a switch-case statement to route events based on their routingKey. This creates a Rigid Design where adding a new event type requires modifying the Dispatcher's source code, violating the Open/Closed Principle.

    The current implementation also has hardcoded dependencies on specific handler types (`FileDetectedHandler`, `FileChunkHandler`, etc.), making the system difficult to extend or test in isolation.
âŒ Before:

func (d *EventDispatcher) Dispatch(routingKey string, data []byte) error {
    switch routingKey {
    case "file.detected":
        // Logic for file.detected...
    case "file.chunk":
        // Logic for file.chunk...
    default:
        return fmt.Errorf("unknown routing key: %s", routingKey)
    }
    return nil
}
Adding any new event requires modifying the switch block and the EventDispatcher struct.

âœ… After:

// Using a Dynamic Handler Registry
func (d *EventDispatcher) Dispatch(routingKey string, data []byte) error {
    handler, exists := d.handlers[routingKey]
    if !exists {
        return fmt.Errorf("unknown routing key: %s", routingKey)
    }

    return handler.Handle(data)
}
ğŸ§  Explanation:
     By replacing the switch-case with a Dynamic Registry (Map) and a unified Handler interface, we decouple the Dispatcher from specific handler implementations.
    This architecture allows the system to be **Open for Extension** (you can register new handlers at runtime) but **Closed for Modification** (the `Dispatcher` code never needs to change when adding new features). This significantly reduces the risk of introducing regressions and simplifies unit testing through dependency injection.


Refactoring Highlights (Key Changes):
    Interface Introduction: A unified Handler interface was defined for all event handlers.
    Removal of Hardcoded Fields: Direct fields (such as fileHandler, chunkHandler, and pcapHandler) were replaced with a generic map.
    Registration Method: A RegisterHandler function was added to allow dynamic binding of routing keys to their respective handlers at runtime.

    --------------
    ## Improvement #5: Context Propagation for Analysis Control
    â— Type: Stability / Control Improvement
    
    ğŸ“‚ Location: - services/pcap_uploaded.go  - analysis/pcap_analyzer.go 
    
    ğŸ” Description: The current analysis functions (Analyze, RunFullAnalysis) run without any time limits or cancellation mechanisms. If a very large PCAP file is processed, it could hang the system or consume resources indefinitely without a way to stop it.
    
    By introducing `context.Context`, we allow the calling handler to enforce timeouts or cancel the operation if the service is shutting down.
    âŒ Before:
    
    Go
    func (s *PCAPService) Analyze(fileID string, filePath string) error {
        // Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙŠØ³ØªÙ…Ø± Ø­ØªÙ‰ ÙŠÙ†ØªÙ‡ÙŠ Ø§Ù„Ù…Ù„Ù Ø£Ùˆ ÙŠØµÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ÙŠØ¯ÙˆÙŠØ§Ù‹
        for packet := range packetSource.Packets() { ... }
    }
    
    Ù„Ø§ ØªÙˆØ¬Ø¯ ÙˆØ³ÙŠÙ„Ø© Ù„Ø¥ÙŠÙ‚Ø§Ù Ù‡Ø°Ù‡ Ø§Ù„Ø­Ù„Ù‚Ø© Ù…Ù† Ø§Ù„Ø®Ø§Ø±Ø¬ Ø¥Ø°Ø§ Ø§Ø³ØªØºØ±Ù‚Øª ÙˆÙ‚ØªØ§Ù‹ Ø·ÙˆÙŠÙ„Ø§Ù‹. 
    
    âœ… After:
    
    Go
    func (s *PCAPService) Analyze(ctx context.Context, fileID string, filePath string) error {
        for {
            select {
            case <-ctx.Done(): // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø£Ùˆ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
                return ctx.Err()
            case packet, ok := <-packetSource.Packets():
                if !ok { return nil }
                // ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ­Ù„ÙŠÙ„...
            }
        }
    }
    ğŸ§  Explanation: Adding context.Context creates a "Control Signal" that flows from the entry point (Handler) down to the logic (Analyzer). This ensures that resources are freed immediately if a timeout occurs, preventing "Zombies" processes and improving overall system reliability.
    Ø¥Ù„ÙŠÙƒ Ø´Ø±Ø­ Ù…ÙØµÙ„ Ù„Ù„ØªØ­Ø³ÙŠÙ†ÙŠÙ† Ø±Ù‚Ù… 5 Ùˆ 6 Ø¨Ø£Ø³Ù„ÙˆØ¨ ØªØ¹Ù„ÙŠÙ…ÙŠ ÙŠÙˆØ¶Ø­ Ø§Ù„ÙØ§Ø¦Ø¯Ø© Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ù„ÙƒÙ„ Ù…Ù†Ù‡Ù…Ø§:
    
    5ï¸âƒ£ ØªØ­Ø³ÙŠÙ†: ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø³ÙŠØ§Ù‚ (Context Propagation)
    â— Ø§Ù„Ù‡Ø¯Ù: ØªÙˆÙÙŠØ± Ø¢Ù„ÙŠØ© Ù„Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± (Stability & Control).
    
    Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ†: ÙƒØ§Ù†Øª Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Analyze ØªØ¨Ø¯Ø£ Ø¹Ù…Ù„Ù‡Ø§ ÙˆØªØ³ØªÙ…Ø± ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø­Ø²Ù… (Packets) Ø¯ÙˆÙ† Ø£ÙŠ Ù‚ÙŠÙˆØ¯ Ø²Ù…Ù†ÙŠØ©. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ù„Ù Ø§Ù„Ù€ PCAP Ø¶Ø®Ù…Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ØŒ Ø³ÙŠØ¸Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø´ØºÙˆÙ„Ø§Ù‹ Ø¨Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ Ù„Ù„Ø£Ø¨Ø¯ØŒ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥ÙŠÙ‚Ø§ÙÙ‡ Ø¥Ù„Ø§ Ø¨Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.
    
    ÙƒÙŠÙ ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­ØŸ Ù‚Ù…Ù†Ø§ Ø¨Ø¥Ø¯Ø®Ø§Ù„ context.Context ÙÙŠ ØªÙˆÙ‚ÙŠØ¹ Ø§Ù„Ø¯ÙˆØ§Ù„:
    
    ÙÙŠ Ø§Ù„Ø®Ø¯Ù…Ø©: Ø£ØµØ¨Ø­Øª Analyze(ctx context.Context, ...) ØªØ³ØªÙ‚Ø¨Ù„ Ø§Ù„Ø³ÙŠØ§Ù‚.
    
    ÙÙŠ Ø§Ù„Ù…Ø­Ù„Ù„: ØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø­Ù„Ù‚Ø© for range Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© Ø¨Ø­Ù„Ù‚Ø© ØªØ±Ø§Ù‚Ø¨ Ù‚Ù†Ø§Ø© ctx.Done().
    
    Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ø§ Ù…Ù‡Ù…ØŸ
    
    Ø§Ù„Ù…Ù‡Ù„Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© (Timeout): ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­Ø¯ÙŠØ¯ Ø£Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙŠØ¬Ø¨ Ø£Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ù…Ø«Ù„Ø§Ù‹.
    
    Ø§Ù„Ø¥Ù„ØºØ§Ø¡ (Cancellation): Ø¥Ø°Ø§ Ù‚Ø±Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨ØŒ ØªØªÙˆÙ‚Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙÙˆØ±Ø§Ù‹ ÙˆØªØªØ­Ø±Ø± Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙˆØ§Ù„Ù…Ø¹Ø§Ù„Ø¬.
    ----------------------
    ## Fix #6: Correcting Multi-value Returns and Error Handling
    â— Ø§Ù„Ù†ÙˆØ¹: Bug Fix / Syntax Correction
    
    ğŸ“‚ Ø§Ù„Ù…ÙˆÙ‚Ø¹: - Ù…Ù„Ù: analysis/pcap_analyzer.go - Ø§Ù„Ø¯ÙˆØ§Ù„: RunFullAnalysis Ùˆ AnalyzePCAP 
    
    ğŸ” Ø§Ù„ÙˆØµÙ: Ø¸Ù‡Ø± Ø®Ø·Ø£ÙŠÙ† Ø¨Ø±Ø¬ÙŠÙŠÙ† ÙÙŠ Ø§Ù„ÙƒÙˆØ¯: 1. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… ctx.Err() ÙˆÙƒØ£Ù†Ù‡ Ù…ØµÙÙˆÙØ© (Slice) Ù…Ù…Ø§ ØªØ³Ø¨Ø¨ ÙÙŠ Ø®Ø·Ø£ "invalid operation". 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù‚ÙŠÙ…Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ù† Ø¯Ø§Ù„Ø© GetFileHandle Ø¨ÙŠÙ†Ù…Ø§ Ù‡ÙŠ ØªØ¹ÙŠØ¯ Ù‚ÙŠÙ…ØªÙŠÙ† (Handle Ùˆ Error).
    
    âŒ Ù‚Ø¨Ù„ (Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¶Ø­Ø© ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©):
    
    Go
    // Ø®Ø·Ø£ 1: Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù…Ù„ slice Ù„Ù„Ø®Ø·Ø£
    return ctx.Err()[cite:1] 
    
    // Ø®Ø·Ø£ 2: Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù‚ÙŠÙ…Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
    handle := GetFileHandle(filePath)[cite:1, 11]
    âœ… Ø¨Ø¹Ø¯ (Ø§Ù„ØªØµØ­ÙŠØ­):
    
    Go
    // ØªØµØ­ÙŠØ­ 1: Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø®Ø·Ø£ Ù…Ø¨Ø§Ø´Ø±Ø© ÙƒÙ‚ÙŠÙ…Ø©
    return ctx.Err()
    
    // ØªØµØ­ÙŠØ­ 2: Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ù‚ÙŠÙ…ØªÙŠÙ† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    handle, err := GetFileHandle(filePath)
    ğŸ§  Ø§Ù„Ø´Ø±Ø­: ÙÙŠ Ù„ØºØ© GoØŒ Ø¹Ù†Ø¯Ù…Ø§ ØªØ¹ÙŠØ¯ Ø§Ù„Ø¯Ø§Ù„Ø© Ù‚ÙŠÙ…ØªÙŠÙ†ØŒ ÙŠØ¬Ø¨ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„Ù‡Ù…Ø§ Ù…Ø¹Ø§Ù‹ Ø£Ùˆ ØªØ¬Ø§Ù‡Ù„ Ø£Ø­Ø¯Ù‡Ù…Ø§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… _. Ø£ÙŠØ¶Ø§Ù‹ØŒ ctx.Err() ØªØ¹ÙŠØ¯ ÙˆØ§Ø¬Ù‡Ø© Ù…Ù† Ù†ÙˆØ¹ error ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡Ø§ ÙƒÙ€ slice. ØªØµØ­ÙŠØ­ Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙŠØ¶Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ‚Ø± ÙˆØ¢Ù…Ù†.
    
    6ï¸âƒ£ Ø¥ØµÙ„Ø§Ø­: ØªØµØ­ÙŠØ­ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø±Ø§Ø¬Ø¹Ø© ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ (Syntax Fix)
    â— Ø§Ù„Ù‡Ø¯Ù: ØªØµØ­ÙŠØ­ Ø£Ø®Ø·Ø§Ø¡ Ø¨Ø±Ù…Ø¬ÙŠØ© ØªÙ…Ù†Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† Ø§Ù„ØªØ´ØºÙŠÙ„ (Bug Fix).
    
    Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ (Multi-value Return): Ø¯Ø§Ù„Ø© GetFileHandle Ù…ØµÙ…Ù…Ø© Ù„ØªØ¹ÙŠØ¯ Ù‚ÙŠÙ…ØªÙŠÙ†: Ø§Ù„Ù…Ø¤Ø´Ø± Ù„Ù„Ù…Ù„Ù *pcap.Handle ÙˆØ§Ù„Ø®Ø·Ø£ error. ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ØŒ ÙƒØ§Ù† ÙŠØªÙ… Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù‚ÙŠÙ…Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·ØŒ Ù…Ù…Ø§ ÙŠØ³Ø¨Ø¨ ÙØ´Ù„Ø§Ù‹ ÙÙŠ Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¨Ù†Ø§Ø¡ (Compilation).
    
    Ø§Ù„Ø®Ø·Ø£: handle := GetFileHandle(filePath)
    
    Ø§Ù„ØªØµØ­ÙŠØ­: handle, err := GetFileHandle(filePath)
    
    Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© (Invalid Operation on Error): Ø¸Ù‡Ø± Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ctx.Err() ÙƒØ£Ù†Ù‡ Ù…ØµÙÙˆÙØ© Ø£Ùˆ Ø´Ø±ÙŠØ­Ø© (Slice) Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙˆÙ‡Ùˆ ÙÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø© ÙƒØ§Ø¦Ù† Ù…Ù† Ù†ÙˆØ¹ error.
    
    Ø§Ù„Ø®Ø·Ø£: return ctx.Err() (Ø¨Ø³Ø¨Ø¨ ÙˆØ¬ÙˆØ¯ Ø£Ù‚ÙˆØ§Ø³ Ø£Ùˆ Ù…Ø¹Ø§Ù…Ù„Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø© Ø¸Ù‡Ø±Øª ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©).
    
    Ø§Ù„ØªØµØ­ÙŠØ­: Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø®Ø·Ø£ Ù…Ø¨Ø§Ø´Ø±Ø© return ctx.Err() Ù„ÙŠØªÙ…ÙƒÙ† Ø§Ù„Ù…Ø³ØªØ¯Ø¹ÙŠ Ù…Ù† Ù…Ø¹Ø±ÙØ© Ø³Ø¨Ø¨ Ø§Ù„ØªÙˆÙ‚Ù (Ù‡Ù„ Ù‡Ùˆ Timeout Ø£Ù… Cancel).
    
    ---------------------------------------------

## ## Improvement #7: Asynchronous PCAP Analysis (Goroutines)

**â— Type:** Performance / Scalability  
**ğŸ“‚ Location:** `handlers/pcap_uploaded.go`

### ğŸ” Description
Currently, when a `pcap.analyze` event is received, the system performs the analysis synchronously within the main execution path. This blocks the event handler until the entire analysis is finished, which can take a long time for large files and may cause the system to become unresponsive or time out.

By moving the analysis to a **Goroutine**, we allow the handler to acknowledge the event immediately while the heavy processing happens in the background.

### âŒ Before (Synchronous/Blocking)
```go
func (h *PCAPAnalyzeHandler) Handle(event events.PCAPAnalyzeEvent) error {
    ctx := context.Background()
    // The handler waits here until Analyze is finished (Blocking)
    return h.pcapService.Analyze(ctx, event.FileID, event.FilePath) 
}
âœ… After (Asynchronous/Non-blocking)
Go
func (h *PCAPAnalyzeHandler) Handle(event events.PCAPAnalyzeEvent) error {
    ctx := context.Background()

    // Start analysis in a background goroutine
    go func() {
        err := h.pcapService.Analyze(ctx, event.FileID, event.FilePath)
        if err != nil {
            // Log the error (Analysis failed in background)
            fmt.Printf("Background analysis failed for %s: %v\n", event.FileID, err)
        }
    }()

    return nil // Return immediately to acknowledge the event
}
6ï¸âƒ£ ØªØ­Ø³ÙŠÙ†: ÙØµÙ„ ØªØ­Ù„ÙŠÙ„ PCAP Ø¹Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Asynchronous Analysis)
â— Ø§Ù„Ù‡Ø¯Ù: ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© (Performance & Responsiveness).

ğŸ”§ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ†:
ÙƒØ§Ù†Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„ ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ù…ØªØ²Ø§Ù…Ù† (Synchronous)ØŒ Ù…Ù…Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù† Ø§Ù„Ù€ Handler ÙŠØ¸Ù„ "Ù…Ø­Ø¬ÙˆØ²Ø§Ù‹" ÙˆÙŠÙ†ØªØ¸Ø± Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù‚Ø¨Ù„ Ø£Ù† ÙŠØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø£ÙŠ Ø­Ø¯Ø« Ø¬Ø¯ÙŠØ¯. ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø©ØŒ Ù‚Ø¯ ÙŠØ¤Ø¯ÙŠ Ø°Ù„Ùƒ Ù„ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„Ù†Ø¸Ø§Ù… Ø£Ùˆ ØªØ¬Ø§ÙˆØ² Ù…Ù‡Ù„Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± (Timeout) ÙÙŠ Ø·Ø§Ø¨ÙˆØ± Ø§Ù„Ø±Ø³Ø§Ø¦Ù„.

âœ… ÙƒÙŠÙ ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­ØŸ
ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Goroutines Ù„ØªØ´ØºÙŠÙ„ Ø¯Ø§Ù„Ø© Analyze ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©:

Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ÙÙˆØ±ÙŠØ©: ÙŠÙ‚ÙˆÙ… Ø§Ù„Ù€ Handler Ø¨Ø¥Ù†Ù‡Ø§Ø¡ Ù…Ù‡Ù…ØªÙ‡ ÙˆØ¥Ø¹Ø§Ø¯Ø© nil ÙÙˆØ±Ø§Ù‹ Ø¨Ù…Ø¬Ø±Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©.

Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠ: ÙŠÙ…ÙƒÙ† Ù„Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¢Ù† Ø¨Ø¯Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù„ÙØ§Øª Ù…ØªØ¹Ø¯Ø¯Ø© ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª Ø¯ÙˆÙ† Ø£Ù† ØªÙ†ØªØ¸Ø± ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªÙŠ Ù‚Ø¨Ù„Ù‡Ø§.

ğŸ§  Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ø§ Ù…Ù‡Ù…ØŸ
ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: Ø§Ù„Ù†Ø¸Ø§Ù… Ù„Ø§ ÙŠØ¨Ø¯Ùˆ "Ù…Ø¹Ù„Ù‚Ø§Ù‹" Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¶Ø®Ù…Ø©.

ØªÙˆÙÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø±Ø¯: ÙŠØ³Ù…Ø­ Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ RabbitMQ (Ø£Ùˆ Ø£ÙŠ Ù…ØµØ¯Ø± Ø£Ø­Ø¯Ø§Ø«) Ø¨Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­ ÙÙˆØ± Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ù…Ù‡Ù…Ø©ØŒ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ù‚Ù†Ø§Ø© Ù…ÙØªÙˆØ­Ø© Ù„ÙˆÙ‚Øª Ø·ÙˆÙŠÙ„.

--------------------------
## Improvement: Event Versioning & Compatibility
â— Ø§Ù„Ù†ÙˆØ¹: Compatibility / Robustness

ğŸ“‚ Ø§Ù„Ù…Ù„ÙØ§Øª: - events/event.go - handlers/dispatcher.go

ğŸ” Ø§Ù„ÙˆØµÙ: ÙŠØ­ØªÙˆÙŠ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Event Ø¹Ù„Ù‰ Ø­Ù‚Ù„ Version ÙˆÙ„ÙƒÙ†Ù‡ ÙƒØ§Ù† ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ Dispatcher ÙŠØ¶Ù…Ù† Ø£Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ù„Ø§ ÙŠØ­Ø§ÙˆÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø­Ø¯Ø§Ø« Ù‚Ø¯ÙŠÙ…Ø© Ø£Ùˆ Ø¥ØµØ¯Ø§Ø±Ø§Øª Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø©ØŒ Ù…Ù…Ø§ ÙŠØ­Ù…ÙŠ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ù† Ø£Ø®Ø·Ø§Ø¡ Ø§Ø®ØªÙ„Ø§Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Schema Mismatch).

âŒ Ù‚Ø¨Ù„: ÙƒØ§Ù† Ø§Ù„Ù€ Dispatcher ÙŠÙˆØ¬Ù‡ Ø§Ù„Ø­Ø¯Ø« Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù€ routingKey Ø¯ÙˆÙ† Ø§Ù„Ù†Ø¸Ø± Ø¥Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ø¥ØµØ¯Ø§Ø±ØŒ Ù…Ù…Ø§ Ù‚Ø¯ ÙŠØ¤Ø¯ÙŠ Ù„Ø§Ù†Ù‡ÙŠØ§Ø± Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¥Ø°Ø§ ØªØºÙŠØ± Ø´ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„.

âœ… Ø¨Ø¹Ø¯: Ø£ØµØ¨Ø­ Ø§Ù„Ù€ Dispatcher ÙŠÙ‚ÙˆÙ… Ø¨ÙÙƒ ØªØ´ÙÙŠØ± "Ø§Ù„ØºÙ„Ø§Ù" (Envelope) Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥ØµØ¯Ø§Ø±:

Go
// ÙØ­Øµ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ù‚Ø¨Ù„ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡
var baseEvent events.Event
json.Unmarshal(data, &baseEvent)

if baseEvent.Version != 1 {
    return fmt.Errorf("unsupported version: %d", baseEvent.Version)
}
// Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬...
ğŸ§  Ø§Ù„Ø´Ø±Ø­: 1. Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ù‡Ù…Ù„: ØªÙØ¹ÙŠÙ„ Ø­Ù‚Ù„ Version Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ø£ØµÙ„Ø§Ù‹ ÙÙŠ Ù…Ù„Ù event.go. 2. Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù†Ø¸Ø§Ù…: Ù…Ù†Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø§ ØªØªÙˆØ§ÙÙ‚ Ù…Ø¹ "Ø§Ù„Ø¥ØµØ¯Ø§Ø± 1" Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ… Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ Ù…Ù…Ø§ ÙŠÙ…Ù†Ø¹ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„. 3. Ø§Ù„ØªÙˆØ³Ø¹ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ: Ù‡Ø°Ø§ Ø§Ù„ØªØ­Ø³ÙŠÙ† ÙŠØ³Ù‡Ù„ Ø¹Ù„ÙŠÙƒ Ù…Ø³ØªÙ‚Ø¨Ù„Ø§Ù‹ Ø¯Ø¹Ù… "Ø§Ù„Ø¥ØµØ¯Ø§Ø± 2" Ø¨Ø¬Ø§Ù†Ø¨ "Ø§Ù„Ø¥ØµØ¯Ø§Ø± 1" Ø¯ÙˆÙ† ÙƒØ³Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø¯ÙŠÙ….

Ù…Ù„Ø®Øµ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Øª ÙÙŠ Ù…Ù„Ù handlers/dispatcher.go:
ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ø£ÙˆÙ„ÙŠ: Ø¥Ø¶Ø§ÙØ© json.Unmarshal Ù„Ù‡ÙŠÙƒÙ„ Event Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù‚Ø¨Ù„ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡.

Ø´Ø±Ø· Ø§Ù„ØªØ­Ù‚Ù‚: Ø¥Ø¶Ø§ÙØ© Ø¬Ù…Ù„Ø© if ØªÙ‚Ø§Ø±Ù† baseEvent.Version Ø¨Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ… (Ø§Ù„Ø¥ØµØ¯Ø§Ø± 1).

Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: Ø¥Ø±Ø¬Ø§Ø¹ Ø®Ø·Ø£ ÙˆØ§Ø¶Ø­ ÙÙŠ Ø­Ø§Ù„ ÙƒØ§Ù† Ø§Ù„Ø¥ØµØ¯Ø§Ø± ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…ØŒ Ù…Ù…Ø§ ÙŠØ³Ø§Ø¹Ø¯ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù€ Debugging.