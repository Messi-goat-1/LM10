## Problem #1: Chunk Order Validation

â— **Type:**  
Data Integrity Bug
---
ğŸ“‚ **Location:**  
- **File:** `services/file_chunk.go`  
- **Functions:**  
  - `Manager.isComplete`  
  - `Manager.reassemble`
---
ğŸ” **Description:**  
    The completion logic relied only on the number of files in the chunk directory.  
    This allowed missing or unordered chunks to be treated as a complete file,  
    leading to silent data corruption during reassembly.
---
âŒ **Before (`isComplete`):**
```go
files, _ := os.ReadDir(dir)
return len(files) == total

âœ… After (isComplete):

for i := 0; i < total; i++ {
    partPath := filepath.Join(dir, fmt.Sprintf("part_%d", i))
    if _, err := os.Stat(partPath); err != nil {
        return false
    }
}
return true
------------
âŒ Before (reassemble):

    Relied on directory listing order
    Did not enforce strict chunk sequence

âœ… After (reassemble):

for i := 0; i < totalChunks; i++ {
    partPath := filepath.Join(tempDir, fmt.Sprintf("part_%d", i))
    data, err := os.ReadFile(partPath)
    if err != nil {
        return fmt.Errorf("missing chunk %d: %w", i, err)
    }
    out.Write(data)
}

ğŸ§  Explanation:
    Ensures all required chunks (part_0 â†’ part_(n-1)) exist before reassembly
    Enforces strict, deterministic chunk order during file reconstruction
    Prevents silent corruption caused by missing or unordered chunks

ğŸ§ª Tests (to be added):
    TestManager_isComplete_MissingChunk
    TestManager_isComplete_AllChunksPresent
    TestManager_reassemble_MissingChunk
    TestManager_reassemble_OrderEnforced

----------------------------------
## Problem #2: Prevent Duplicate Chunk Writes (Idempotency)

â— Type:
    Data Consistency Bug

ğŸ“‚ Location:
    - File: services/file_chunk.go
    - Function: Manager.OnChunkReceived

ğŸ” Description:
    The same chunk may be received more than once due to retries or duplicate
    events. Writing the chunk blindly can overwrite existing data and lead to
    file corruption during reassembly.

âŒ Before:

os.WriteFile(chunkPath, data, 0644)

    This implementation overwrites existing chunks without validation.

âœ… After:
if existing, err := os.ReadFile(chunkPath); err == nil {
	if bytes.Equal(existing, data) {
		return nil // safe duplicate chunk
	}
	return fmt.Errorf(
		"chunk %d already exists with different content",
		chunkIndex,
	)
}

os.WriteFile(chunkPath, data, 0644)
s.WriteFile(chunkPath, data, 0644)
---
ğŸ§  Explanation:
    Ensures chunk writes are idempotent while preserving data integrity.
    Duplicate chunks with identical content are safely ignored, while conflicting
    duplicates are rejected to prevent silent data corruption.

ğŸ§ª Tests:
    TestOnChunkReceived_DuplicateChunkIgnored
    TestOnChunkReceived_DuplicateChunkConflict
âœ… Status:
    [x] Fixed
    [ ] Tested
-----------------------------------------------
## Problem #3: Ignoring JSON Unmarshal Errors

â— Type:
    Error Handling Bug

ğŸ“‚ Location:
    - File: handlers/dispatcher.go
    - Function: EventDispatcher.Dispatch

ğŸ” Description:
    Incoming event payloads are deserialized using `json.Unmarshal` without
    checking the returned error. If the JSON payload is malformed, incomplete,
    or does not match the expected event structure, the system will silently
    continue execution with a zero-value event.

    This can lead to invalid handlers being executed with corrupted data,
    causing unpredictable behavior that is difficult to debug.

âŒ Before:

var event events.FileChunkEvent
json.Unmarshal(data, &event)
d.chunkHandler.Handle(event)

The error returned by json.Unmarshal is ignored.

âœ… After:
var event events.FileChunkEvent
if err := json.Unmarshal(data, &event); err != nil {
	return err
}
d.chunkHandler.Handle(event)
ğŸ§  Explanation:
    JSON deserialization is a trust boundary. Ignoring unmarshal errors allows
    invalid or corrupted messages to propagate through the system silently.
    By explicitly handling the error, the dispatcher ensures that only valid
    events reach their handlers, improving system reliability and debuggability.

ğŸ§ª Tests:
    TestDispatch_InvalidJSON_ReturnsError
    TestDispatch_ValidEvent_DispatchedCorrectly

---------------------------------------
## Problem #4: Dispatcher Violates Open/Closed Principle (OCP)

â— Type:
Design Improvement (Architecture)

ğŸ“‚ Location:
- File: handlers/dispatcher.go
- Function: EventDispatcher.Dispatch
- Section: switch routingKey { ... }

ğŸ” Description:
The dispatcher relies on a `switch` statement to route events based on
their routing key. Each time a new event type is introduced, the dispatcher
must be modified to add a new `case`.

This design violates the Open/Closed Principle (OCP), where the system
should be open for extension but closed for modification.

âŒ Before:

switch routingKey {

case "file.detected":
	var event events.FileDetectedEvent
	if err := json.Unmarshal(data, &event); err != nil {
		return err
	}
	d.fileHandler.Handle(event)

case "file.chunk":
	var event events.FileChunkEvent
	if err := json.Unmarshal(data, &event); err != nil {
		return err
	}
	d.chunkHandler.Handle(event)

case "pcap.analyze":
	var event events.PCAPAnalyzeEvent
	if err := json.Unmarshal(data, &event); err != nil {
		return err
	}
	return d.pcapHandler.Handle(event)

default:
	return fmt.Errorf("unknown routing key: %s", routingKey)
}

Each new event requires modifying this function.

âœ… After:
