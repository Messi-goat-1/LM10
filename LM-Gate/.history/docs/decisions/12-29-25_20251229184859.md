## Problem #1: Chunk Order Validation

â— **Type:**  
Data Integrity Bug
---
ğŸ“‚ **Location:**  
- **File:** `services/file_chunk.go`  
- **Functions:**  
  - `Manager.isComplete`  
  - `Manager.reassemble`
---
ğŸ” **Description:**  
    The completion logic relied only on the number of files in the chunk directory.  
    This allowed missing or unordered chunks to be treated as a complete file,  
    leading to silent data corruption during reassembly.
---
âŒ **Before (`isComplete`):**
go
files, _ := os.ReadDir(dir)
return len(files) == total

âœ… After (isComplete):

for i := 0; i < total; i++ {
    partPath := filepath.Join(dir, fmt.Sprintf("part_%d", i))
    if _, err := os.Stat(partPath); err != nil {
        return false
    }
}
return true
------------
âŒ Before (reassemble):

    Relied on directory listing order
    Did not enforce strict chunk sequence

âœ… After (reassemble):

for i := 0; i < totalChunks; i++ {
    partPath := filepath.Join(tempDir, fmt.Sprintf("part_%d", i))
    data, err := os.ReadFile(partPath)
    if err != nil {
        return fmt.Errorf("missing chunk %d: %w", i, err)
    }
    out.Write(data)
}

ğŸ§  Explanation:
    Ensures all required chunks (part_0 â†’ part_(n-1)) exist before reassembly
    Enforces strict, deterministic chunk order during file reconstruction
    Prevents silent corruption caused by missing or unordered chunks

ğŸ§ª Tests (to be added):
    TestManager_isComplete_MissingChunk
    TestManager_isComplete_AllChunksPresent
    TestManager_reassemble_MissingChunk
    TestManager_reassemble_OrderEnforced

----------------------------------
## Problem #2: Prevent Duplicate Chunk Writes (Idempotency)

â— Type:
    Data Consistency Bug

ğŸ“‚ Location:
    - File: services/file_chunk.go
    - Function: Manager.OnChunkReceived

ğŸ” Description:
    The same chunk may be received more than once due to retries or duplicate
    events. Writing the chunk blindly can overwrite existing data and lead to
    file corruption during reassembly.

âŒ Before:

os.WriteFile(chunkPath, data, 0644)

    This implementation overwrites existing chunks without validation.

âœ… After:
if existing, err := os.ReadFile(chunkPath); err == nil {
	if bytes.Equal(existing, data) {
		return nil // safe duplicate chunk
	}
	return fmt.Errorf(
		"chunk %d already exists with different content",
		chunkIndex,
	)
}

os.WriteFile(chunkPath, data, 0644)
s.WriteFile(chunkPath, data, 0644)
---
ğŸ§  Explanation:
    Ensures chunk writes are idempotent while preserving data integrity.
    Duplicate chunks with identical content are safely ignored, while conflicting
    duplicates are rejected to prevent silent data corruption.

ğŸ§ª Tests:
    TestOnChunkReceived_DuplicateChunkIgnored
    TestOnChunkReceived_DuplicateChunkConflict
âœ… Status:
    [x] Fixed
    [ ] Tested
-----------------------------------------------
## Problem #3: Ignoring JSON Unmarshal Errors

â— Type:
    Error Handling Bug

ğŸ“‚ Location:
    - File: handlers/dispatcher.go
    - Function: EventDispatcher.Dispatch

ğŸ” Description:
    Incoming event payloads are deserialized using `json.Unmarshal` without
    checking the returned error. If the JSON payload is malformed, incomplete,
    or does not match the expected event structure, the system will silently
    continue execution with a zero-value event.

    This can lead to invalid handlers being executed with corrupted data,
    causing unpredictable behavior that is difficult to debug.

âŒ Before:

var event events.FileChunkEvent
json.Unmarshal(data, &event)
d.chunkHandler.Handle(event)

The error returned by json.Unmarshal is ignored.

âœ… After:
var event events.FileChunkEvent
if err := json.Unmarshal(data, &event); err != nil {
	return err
}
d.chunkHandler.Handle(event)
ğŸ§  Explanation:
    JSON deserialization is a trust boundary. Ignoring unmarshal errors allows
    invalid or corrupted messages to propagate through the system silently.
    By explicitly handling the error, the dispatcher ensures that only valid
    events reach their handlers, improving system reliability and debuggability.

ğŸ§ª Tests:
    TestDispatch_InvalidJSON_ReturnsError
    TestDispatch_ValidEvent_DispatchedCorrectly

---------------------------------------
## Improvement #4: Event Dispatcher (OCP)
â— Type: Design Improvement (Open/Closed Principle)

ğŸ“‚ Location: 
    - File: handlers/dispatcher.go - Function: EventDispatcher.Dispatch

ğŸ” Description:
    The dispatcher currently uses a switch-case statement to route events based on their routingKey. This creates a Rigid Design where adding a new event type requires modifying the Dispatcher's source code, violating the Open/Closed Principle.

    The current implementation also has hardcoded dependencies on specific handler types (`FileDetectedHandler`, `FileChunkHandler`, etc.), making the system difficult to extend or test in isolation.
âŒ Before:

func (d *EventDispatcher) Dispatch(routingKey string, data []byte) error {
    switch routingKey {
    case "file.detected":
        // Logic for file.detected...
    case "file.chunk":
        // Logic for file.chunk...
    default:
        return fmt.Errorf("unknown routing key: %s", routingKey)
    }
    return nil
}
Adding any new event requires modifying the switch block and the EventDispatcher struct.

âœ… After:

// Using a Dynamic Handler Registry
func (d *EventDispatcher) Dispatch(routingKey string, data []byte) error {
    handler, exists := d.handlers[routingKey]
    if !exists {
        return fmt.Errorf("unknown routing key: %s", routingKey)
    }

    return handler.Handle(data)
}
ğŸ§  Explanation:
     By replacing the switch-case with a Dynamic Registry (Map) and a unified Handler interface, we decouple the Dispatcher from specific handler implementations.
    This architecture allows the system to be **Open for Extension** (you can register new handlers at runtime) but **Closed for Modification** (the `Dispatcher` code never needs to change when adding new features). This significantly reduces the risk of introducing regressions and simplifies unit testing through dependency injection.


Refactoring Highlights (Key Changes):
    Interface Introduction: A unified Handler interface was defined for all event handlers.
    Removal of Hardcoded Fields: Direct fields (such as fileHandler, chunkHandler, and pcapHandler) were replaced with a generic map.
    Registration Method: A RegisterHandler function was added to allow dynamic binding of routing keys to their respective handlers at runtime.