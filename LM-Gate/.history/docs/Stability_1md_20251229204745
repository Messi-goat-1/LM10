

5ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Context Ù„Ù„ØªØ­Ù„ÙŠÙ„

â— Ø§Ù„Ù†ÙˆØ¹: Stability / Control
ðŸ“‚ Ø§Ù„Ù…Ù„ÙØ§Øª:

services/pcap_uploaded.go

analysis/pcap_analyzer.go

ðŸ“ Ø§Ù„Ù…ÙƒØ§Ù†:

func Analyze(...)


ðŸ”§ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:

Ù„Ø§ ÙŠÙˆØ¬Ø¯ timeout Ø£Ùˆ cancel

âœ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­:

Ø§Ø³ØªØ®Ø¯Ø§Ù… context.Context

ØªÙ…Ø±ÙŠØ±Ù‡ Ù…Ù† handler â†’ service â†’ analyzer


---------------------------------------
package services

import (
	"fmt"

	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
)

// PCAPService is responsible for analyzing PCAP files.
//
// NOTE: This service focuses only on PCAP analysis logic.
// It does not handle file upload, storage, or events.
// TODO: Add support for structured output instead of printing packets.
type PCAPService struct{}

// NewPCAPService creates a new PCAPService instance.
//
// NOTE: Currently stateless.
// TODO: Inject configuration or logger if needed.
func NewPCAPService() *PCAPService {
	return &PCAPService{}
}

// Analyze performs the actual PCAP analysis.
//
// NOTE: This is the core analysis logic.
// It opens the PCAP file and reads packets one by one.
// FIXME: Currently stops after analyzing only a few packets.
func (s *PCAPService) Analyze(fileID string, filePath string) error {
	// Open the PCAP file from disk (offline mode)
	handle, err := pcap.OpenOffline(filePath)
	if err != nil {
		return fmt.Errorf("failed to open PCAP (%s): %w", fileID, err)
	}
	defer handle.Close()

	// Create a packet source to read packets
	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

	count := 0
	for packet := range packetSource.Packets() {
		count++
		fmt.Printf("\n[PCAP:%s] Packet #%d\n", fileID, count)

		// Print full packet details (IPs, ports, payload, etc.)
		fmt.Println(packet.String())

		// Temporary limit for testing
		if count >= 2 {
			break
		}
	}

	return nil
}
--------------------
package analysis

import (
	"fmt"

	"github.com/google/gopacket"
	"github.com/google/gopacket/pcap"
)

// GetFileHandle opens a PCAP file from disk (offline mode).
//
// NOTE: This function is purely technical.
// It only opens the file and prepares it for reading.
// TODO: Add file existence and permission checks before opening.
func GetFileHandle(filePath string) (*pcap.Handle, error) {
	handle, err := pcap.OpenOffline(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %v", err)
	}
	return handle, nil
}

// RunFullAnalysis performs the actual packet analysis.
//
// NOTE: This function is the analysis engine.
// It reads packets one by one from the PCAP file.
// FIXME: Currently stops after a small number of packets.
// TODO: Analyze all packets and extract structured data.
func RunFullAnalysis(handle *pcap.Handle) {
	packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

	// Test only the first few packets to inspect the structure
	count := 0
	for packet := range packetSource.Packets() {
		count++
		fmt.Printf("\n--- Packet #%d ---\n", count)

		// This prints all packet details (IPs, Ports, Payload, etc.)
		fmt.Println(packet.String())

		if count >= 2 {
			break
		}
	}
}

// AnalyzePCAP is the main function called by server.go.
//
// NOTE: This function connects file handling with analysis logic.
// It opens the file first, then runs the full analysis.
// TODO: Pass context for cancellation or timeouts.
func AnalyzePCAP(fileID string, filePath string) error {
	// Step 1: Open the PCAP file
	handle, err := GetFileHandle(filePath)
	if err != nil {
		return err
	}
	defer handle.Close()

	// Step 2: Run packet analysis
	RunFullAnalysis(handle)

	return nil
}
